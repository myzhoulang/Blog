{"pages":[],"posts":[{"title":"centos 7.6 下安装Docker和启动配置","text":"安装环境 Linux 系统内核 3.10 (使用 uname -r查看) curl 文件传输工具 （没有 curl 可使用 yum -y install curl） 步骤 使用curl -sSL https://get.docker.com/ | sh安装docker 使用docker -v查看docker版本。 设置国内镜像源。修改 /etc/docker/daemon.json。如果没有这个文件，就创建一个。 1234# vi /etc/docker/daemon.json{ &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]} 使用systemctl start docker启动docker。 使用 systemctl enable docker将docker加入开启启动。 安装 docker-compose 使用sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose安装docker-compose。 使用sudo chmod +x /usr/local/bin/docker-compose对二进制文件应用可执行权限。 Docker 学习 Docker 官网 Docker 文档 Docker 官方镜像库","link":"/blog/2019/11/12/Centos%207.6%E4%B8%8B%E5%AE%89%E8%A3%85Docker%E5%92%8C%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE/"},{"title":"Dockerfile指令","text":"Dockerfile 由一行行命令语句组成，注释以 #开头。Dockerfile 分为 4 部分：基础镜像，维护者信息，镜像操作指令，容器启动时执行的指令。每执行一个指令，都会创建一个镜像层并对镜像进行提交。导致构建的镜像臃肿。 指令 FROM FROM 是需要基于基础的镜像。FROM是必须的并且必须是第一条指令。推荐使用官方的镜像。 格式 123# 没有`tag`默认是`latest`。FROM &lt;image&gt;FROM &lt;image&gt;:&lt;tag&gt; 案例 1FROM ubuntu:18.04 RUN RUN是用来执行命令行命令的。RUN指令有两种格式。由于每一次执行都会添加一个层，为了减少层，可以使用一个 RUN 执行多个命令。多个命令之间使用&amp;&amp;分割。为了可读性，可以将每一个命令换行，每一行后面加上换行符（\\）即可。有时候构建需要一些额外的资源，这些资源并不会被删除，会一直跟着镜像。导致镜像很大。为减少镜像大小，可在最后删除掉这些无关的文件，只保留正在需要的东西。 格式 12RUN wget -O - https://some.site | wc -l &gt; /numberRUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;] 案例 1RUN mkdir -p app &amp;&amp; apt-get update &amp;&amp; npm install CMD CMD指令用于指定容器启动时需要运行的命令。 格式 1CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;] 案例 1CMD ['npm', 'app'] 注意：使用docker run命令可以覆盖 CMD 指令 ，假设Dockerfile 中的 CMD为CMD [&quot;npm&quot;, 'app'], 当执行 docker run -it app /bin/bash的时候，并不会执行 npm app 而是执行 /bin/bash。 EXPOSE EXPOSE指令告诉 Docker 该容器内的应用程序将会使用容器的指定端口。可以使用多个EXPOSE指令向外部公开多个端口。 格式 1EXPOSE &lt;port&gt; 案例 1EXPOSE 3000 ENV ENV指令用来在镜像构建过程中设置环境变量。这些环境变量也会被持久保存到创建的容器中。可以通过docker run -e &quot;NODE_ENV=test&quot;传递环境变量。 格式 1ENV &lt;key&gt; &lt;value&gt; 案例 1ENV NODE_ENV test ADD ADD指令与COPY格式和性质基本一致。ADD的源路径可以是一个URL。尽可能使用 copy。只有当 COPY达不到要求的时候才使用。类如源路径是远程的链接地址。 COPY COPY指令将从构建上下文目录中的文件复制到新的一层镜像内的位置。格式： 1COPY &lt;原路径&gt; &lt;目标路径&gt; 案例 1COPY package*.json /app/ ENTRYPOINT ENTRYPOINT指令和COPY类似。区别在于ENTRYPOINT不会在容器启动时被覆盖。docker run命令行中指定的参数都会被当做参数传递给 ENTRYPOINT。 VOLUME VOLUME指令用来创建一个可以从本地或其他容器挂载的挂载点，用于数据持久化。 格式 1VOLUME [主机目录] 案例 1VOLUME ['/data', '/logs'] USER USER指令指定镜像会以什么样的用户去运行。可以通过docker run -u nginx覆盖该指令。不指定将会以root用户运行。 格式 1USER &lt;用户&gt; 案例 1USER nginx WORKDIR WORKDIR指令是在从该镜像创建容器时。在容器内部创建一个工作目录，ENTRYPOINT和CMD 指定的程序会在这个目录下执行。在docker run时候可以使用-w覆盖工作录。WORKDIR指令可以为 Dockerfile中其他指令设置工作目录。 格式 1WORKDIR &lt;path&gt; 案例 1WORKDIR /usr/src/api ONBUILD ONBUILD指令式当以当前镜像为基础镜像，去构建下一级镜像的时候被执行。 格式 1ONBUILD &lt;其他指令&gt; 案例 1ONBUILD COPY ./package.json /app MANITAINERMANITAINER指令指定该镜像的作者信息。姓名和联系方式 格式 1MANITAINER &lt;姓名&gt; &lt;联系方式&gt; 案例 1MANITAINER James &quot;james@example.com&quot; LABEL LABEL指令用于为该镜像添加一些元数据，元数据以键值对的形式展示。 格式 12LABEL &lt;key=value&gt; &lt;key1=value1&gt;... 案例 1LABEL location=&quot;New Youk&quot; type=&quot;Data Center&quot;","link":"/blog/2019/11/12/Dockerfile%E6%8C%87%E4%BB%A4/"},{"title":"TypeScript基础类型.md","text":"基础类型 number(数字)number包含整数和小数。可以有二级制，八进制，十进制,十六进制表示法。 1234let num: number = 6; // 十进制let num: number = 0xf00d; // 十六进制let num: number = 0b1010; // 二进制let num: number = 0o744 // 八进制 string(字符串)string类型使用&quot;，'，(`)表示。 123let str: string = &quot;string&quot;;let str: string = 'string';let str: string = `string${foo}`; boolean(布尔)boolean的值只有 true 和 false。 1234let checked: boolean = true;let checked: boolean = false;let checked: boolean = Boolean(true);let checked: boolean = Boolean(false); array(数组)array类型在ts中有两种表示方法。类型定义一种使用数据类型[],另一种使用Array&lt;数据类型&gt;。如果需要在一个数组中有多种不同类型的可以结合联合类型定义。 12let arr:number[] = [1,2,3,4];let arr:Array&lt;number&gt; = [1,2,3,4] tuple(元组)tuple类型是ts中新增的。表示一个已知元素数量和类型的数组。并且值需要和类型的顺序保存一致。⚡️：元组和数组之间的区别在于: 元组更严格，元素的数量，类型, 顺序,都需要保持一致。 12345let t:[string, number] = [&quot;abc&quot;, 1];// ❌ 案例 let t:[string, number] = [1, &quot;abc&quot;]; // 值和类型的定义顺序不对let t:[string, number] = [&quot;1bc&quot;, 1, 2]; // 元素得数量不匹配 enum(枚举)enum类型也是ts中新增的。使用枚举类型可以为一组数值赋予友好的名字。表示一个可以通过key取到value,也可以通过value取到key的对象。 1234567891011// 定义const Colors = { RED, BLUE, YELLOW}// 使用const c: Colors = Colors.RED; // 0const c: Colors = Colors.BLUE; // 1const c: string = Colors[0]; // RED anyany类型表示变量可以是任意类型。ts不会去对这个变量做类型检测。 12345let foo: any = 4;foo = 'string';foo = true;let arr: any[] = [1,'a', true]; voidvoid表示没有任何类型。它的值只能是 undefined或null。 123456function fn():void{ console.log(1);}let foo: void = null;let foo: void = undefined; null和undefinednull和undefined是其他所有类型的子类型。⚡️：null值和undefined值可以赋给其他任何类型。当设置strictNullChecks的时候，只能赋给它们自己和void。 12let u:undefined = undefined;let n: null = null; nevernever表示永远不存在的值的类型，常用于抛出错误，死循环, 返回error()的函数， 1234567891011function err():never{ throw new Error()}function fail():never{ return error('error')}function fn():never{ while (true){}} object(对象)object表示非原始类型。 123456789let obj:object = { number: 12}obj.number = 13; // error 不能修改let obj:{x:number, y:string} = { x: 1, y: 'abc'}obj.x = 2; // ok 联合类型对一些值可以是多种类型的变量，需要使用联合类型。 12345678910111213141516171819// 基本类型变量let foo: number | string | boolean;foo = 123;foo = 'abc';foo = false;// 函数function fn(value: string | number):void { // ...}fn(1);fn('abc');// 泛型和数组let arr:(number|string)[] = [1,'string'];let arr: Array&lt;number|string|boolean&gt;;arr = [1, 1, boolean, 'abc']; 类型别名类型别名是给一组或一个类型起一个名称。他只是引用了别的类型，本身不会创建一个类型。 1234type TypeName = number | string | boolean;let foo: TypeName = 123;let foo: TypeName = 'abc';let foo: boolean = false; 类型断言当一个变量可以是多个类型的时候。你已经明确知道这个变量的值是某一种类型，使用这个类型上的某个方法的时候，可能会引发ts报错。 1234let str1: string | number = &quot;123&quot;;// let len: number = str1.length; // error let len: number = (str1 as string).length; // 方法1 let len: number = (&lt;string&gt;str1).length // 方法2 不能再jsx 中使用","link":"/blog/2019/09/17/TypeScript%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B-md/"},{"title":"mongodb查询","text":"find find 简介 Mongodb 使用find进行查询。find有两个参数，第一个参数是指定查询条件。默认是 {}。 12// 不指定任何条件，查询所有db.collections.find(); 指定返回的值 find的第二个参数是指定需要返回哪些字段，这样避免将所有的字段返回，可以节省传输的数据量，也可以节省客户端解码文档的时间和内存消耗。指定字段的值 1 为包含， 0 为排除。默认情况下 _id是总是会返回的，只有当设置为 0 才不会返回。指定的字段中不能同时又包含和排除。 格式 1db.collection.find(&lt;查询条件&gt;, &lt;需要返回的字段&gt;) 12// 返回的文档中只包含 `name` 、`email`和`_id`。db.users.find({ name: &quot;A&quot; }, { name: 1, email: 1 }); 12// 返回文档中除 `name`字段外所有的字段。db.users.find({ name: &quot;A&quot; }, { name: 0 }); 12// 下面的查询出错**`Error`**db.users.find({ name: &quot;A&quot; }, { name: 1, email: 0 }); 查询条件 查询条件 $lt、$gt、$lte、$gte是比较操作符，可以单独使用，也可以组合使用查询一个范围的值。可以比较数字型、时间型的值。 12// 查询 18~30岁（含）的用户db.users.find({ age: { $gte: 18, $lte: 30 } }); 12// 查找2007年1月1日之前注册的用户。db.users.find({ registered: { $lt: new Date(&quot;01/01/2007&quot;) } }); $ne是不等操作符。当查询条件需要正则去匹配的时候，使用$ne会出错。正则类型的可以使用 $not操作符。 12// 查找 `name!=A` 的用户。db.users.find({ name: { $ne: &quot;A&quot; } }); 123// 下面查询`name`字段不以`A`开头的用户，报错了。// Error `Can't have regex as arg to $ne.`db.users.find({ name: { $ne: /^A/ } }); OR 查询 有两种方式进行 OR 查询。一种是使用$in用来查询一个键的多个值，一种是使用$or 可以在多个键中查询任意给定的值。如果需要对$in的匹配条件后取反可以使用$nin。 12// 查询 `status`字段的值是 `1`|`2`|`3`的用户db.users.find({ status: { $in: [1, 2, 3] } }); 12// 查询`status`字段的不是 `1`|`2`|`3`的用户db.users.find({ status: { $nin: [1, 2, 3] } }); 12// 查询 `status`字段是`1` 或者 `age`字段大于`18`的用户db.users.find({ $or: [{ status: 1 }, { age: { $gt: 18 } }] }); $not $not操作符是匹配那些不符合条件的文档。相对$ne ，$not可以结合正则表达式一起使用。 123456789// 查询`name`字段不是 A 的文档db.users.find({ name: { $not: &quot;A&quot; } });// 查询`age`字段不小于1的文档db.users.find({ age: { $not: { $lt: 1 } } });// 结合正则表达式查询// 查询 `name`字段不以字符串 a 开头的db.users.find({ name: { $not: /^a/i } }); 条件语句 查询操作符一般是内层文档的键。更新操作符则是外层文档的键。 特定类型查询 null null类型可以匹配自身，还会匹配那些没有这个键的文档。如果要排除掉没有这个键的文档 需要结合$exists这个操作符。 12345// 下面这样会查询出 字段 x 为 null 和那些没有 x 字段的文档db.users.find({ x: null });// 下面只会查询出 字段 x 为 nulldb.users.find({ x: { $in: [null], $exists: true } }); 正则表达式 正则表达式可以灵活有效的匹配字符串。像对一个字段的模糊查询，忽略大小写等待非常有用。正则表达式也可以匹配到自身，如果字段中的值就是一个正则表达式，也能正确匹配。 12345// 查询字段 name 中包含 (a|A) 的文档db.users.find({ name: /a/i });// 查询字段 name 中包含 (a|A) 开头的文档db.users.find({ name: /^a/i }); 查询数组 单个元素匹配数组 123// 假设 fruit 的值一个数组// 下面的匹配会匹配到 fruit 数组中包含 apple 一项的文档db.foods.find({ fruit: &quot;apple&quot; }); 多个元素匹配数组 123// 假设 fruit 的值一个数组// 下面的匹配会匹配到 fruit 数组中包含 apple 和 banana 的文档db.foods.find({ fruit: { $all: [&quot;apple&quot;, &quot;banana&quot;] } }); 数组精确匹配 数组的精确匹配必须 查询条件 和 文档中的值个数和顺序都必须保持一致。要查询数组中特定位置的元素，可加上数组下标进行查询。 1234567// 假设 fruit 的值一个数组// 下面只会匹配字段 fruit 为 [&quot;apple&quot;, &quot;banana&quot;]的文档db.foods.find({ fruit: [&quot;apple&quot;, &quot;banana&quot;] });// 匹配数组中第一个元素的值// 下面会匹配到 fruit 字段中第一个元素的值是 apple 的文档。db.foods.find({ &quot;fruit.0&quot;: &quot;apple&quot; }); $size $size 对查询字段数组长度很有效。像查询某个字段的数组值只有指定的个数的文档。注意： $size 不能与其他查询条件组合使用。 123// 假设 fruit 的值一个数组// 查询字段 fruit 的个数为 2 个的文档db.foods.find({ fruit: { $size: 2 } }); 5) $slice $slice操作符可以返回某个键匹配数组元素的一个子集。放在 find的第二个参数中。这个操作符不会影响文档其他键的返回。如果指定返回的键，需要显示声明。 123456789// 返回某一个博客的前 10 条评论db.find({ _id: ObjectId(x) }, { comment: { $slice: 10 } });// 返回某一个博客的最后 10 条评论db.find({ _id: ObjectId(x) }, { comment: { $slice: -10 } });// 返回某一个博客的中评论// 跳过前 10 条评论后，取10条db.find({ _id: ObjectId(x) }, { comment: { $slice: [10, 10] } }); $elemMatch 对数组中每一个元素和传入的所有查询条件进行比较。 1234// 假设 x 的值是一个数组// 会对字段 x 进行循环，依次和 $elemMatch 中的条件进行匹配// 只有元素 大于10 并且小于20 才会被命中db.tests.find({ x: { $elemMatch: { $gt: 10, $lt: 20 } } }); 查询内嵌文档 查询内嵌文档有两种方式： 1. 查询整个文档， 2.针对 key/value 进行查询。 精确操作 和 数组的精确查找一样。 内嵌文档的 字段个数、字段顺序、字段名称都需要一致。 key/value 查找 Key/value 查找使用点表示法。当两个查询条件使用了点表示法，他们的关系是 or 的关系。如果需要对两个条件使用 and关系，可以结合 $elemMatch操作符使用。 123456789101112131415// 假设需要查询 有 Joe 发表的 5 分以上的评论// 下面的查询是可能失败的，如果内嵌文档只有这两个字段的时候是OK，// 如果内嵌文档中有额外的字段，就会失败。// 下面的查询是精确匹配db.blogs.find({ comments: { author: &quot;joe&quot;, score: { $gte: 5 } } });// 下面的查询会失败// 下面的查询会匹配到 评论中 author=joe 或者 score &gt;= 5 的文档。db.blogs.find({ &quot;comments.author&quot;: &quot;joe&quot;, &quot;comments.score&quot;: { $gte: 5 } });// 可以使用 $elemMatchdb.blogs.find({ comments: { $elemMatch: { author: &quot;joe&quot;, score: { $gte: 5 } } }}); $where 查询$where可以在查询中指定任意的 JavaScript。为了安全和性能考虑，应尽可能避免使用。 123456db.foo.find({ $where: function() { // 查询逻辑 // 返回 true 文档就作为结果集的一部分返回，返回false 就不返回 }}); 游标 limit、skip、sort limit在find后使用来限制结果数量，skip和limit结合用于分页查询，指定跳过指定条数。sort用于排序，1 为升序，-1 位降序。 123456// 下面的查询跳过前10条，选择10,以 age 升序排序。db.users .find() .skip(10) .limit(10) .sort({ age: 1 }); 参考mongodb 官方文档 MongoDB 权威指南第二版书籍","link":"/blog/2019/11/12/mongodb%E6%9F%A5%E8%AF%A2/"},{"title":"使用Dock搭建Sentry服务","text":"搭建环境 CentOS 7.5 64 位 docker: 18.09.6 docker-compose: 1.24.0 sentry: sentry 9.1-onbuild 搭建步骤 安装 docker、docker-compose、git 执行 systemctl start docker 启动 docker。 1$ systemctl start docker ⚡️: 可执行 systemctl enable docker 将启动 docker 加入开机自启 1$ systemctl enable docker 克隆 sentry到本地。git clone https://github.com/getsentry/onpremise.git。 1$ git clone https://github.com/getsentry/onpremise.git 执行 cd onpremise 进入 onpremise 文件夹。 执行 docker volume create --name=sentry-data &amp;&amp; docker volume create --name=sentry-postgres 1$ docker volume create --name=sentry-data &amp;&amp; docker volume create --name=sentry-postgres ⚡️: 使用 docker volume 创建本地数据库和 sentry 卷。 执行 cp -n .env.example .env 创建 .env 文件。 1$ cp -n .env.example .env 执行 docker-compose build 构建并标记 docker 服务。 1$ docker-compose build 执行 docker-compose run --rm web config generate-secret-key - 生成密钥。将它添加到 .env 作为 SENTRY_SECRET_KEY的值，还要将其添加到 docker-compose.yml中。 1$ docker-compose run --rm web config generate-secret-key 执行 docker-compose run --rm web upgrade - 构建数据库。 1$ docker-compose run --rm web upgrade ⚡️: 官方文档 说这里会 使用交互式提示创建用户帐户 。在实际操作中却没有提示。::如果没有提示需要执行第 10 步::。 执行 docker exec -it onpremise_postgres_1 bash 进入 docker 容器 执行 postgres bash 命令查看是否有数据。 1$ docker exec -it onpremise_postgres_1 bash 执行 psql -h 127.0.0.1 -d postgres -U postgres 进入 postgres 数据库 1$ psql -h 127.0.0.1 -d postgres -U postgres 执行 select * from sentry_project; 查看 sentry_project 表是否有数据。 1$ select * from sentry_project; 执行 select * from sentry_organization; 查看 sentry_organization 表是否有数据。 1$ select * from sentry_organization; 执行 ctrl + d 退出 shell。 如果没有数据需要添加， 执行 docker-compose run --rm web shell 进入 sentry 的 web 的 shell 里面。初始化数据 1$ docker-compose run --rm web shell 执行 from sentry.models import Project。 1$ from sentry.models import Project 执行 from sentry.receivers.core import create_default_projects。 1$ from sentry.receivers.core import create_default_projects 执行 create_default_projects([Project])。 1$ create_default_projects([Project]) 执行 ctrl + d 退出。 执行 docker-compose run --rm web createuser 创建用户。 1docker-compose run --rm web createuser 执行 docker-compose up -d - 构建启动容器。 在浏览器中输入 [ip]:9000。如果没有错误，就应该能看到了。 安装碰到的问题 💥 在执行 docker-compose run --rm web upgrade 的时候。可能会出现没有执行完就退出了终端。 🔨 解决方案: 需要重新执行上面的命令 💥 登录到项目后点击 Create a sample event 测试时， 会发现是失败的，而且这个时候在项目中产生的错误不会在这个 Issues 列表中展示。 🔨 解决方案: 参考：Waiting for events… Our error robot is waiting to devour receive your first event - #sentry 执行 docker exec -it onpremise_postgres_1 bash 进入 docker 容器 执行 postgres bash 命令查看是否有数据。 1$ docker exec -it onpremise_postgres_1 bash 执行 psql -h 127.0.0.1 -d postgres -U postgres 进入 postgres 数据库 1$ psql -h 127.0.0.1 -d postgres -U postgres 执行下面 SQL 语句后。在浏览器中点击 Create a sample event 就好了，也正常记录 Issue 了。 123456789create or replace function sentry_increment_project_counter( project bigint, delta int) returns int as $$ declare new_val int;begin loop update sentry_projectcounter set value = value + delta where project_id = project returning value into new_val;if found then return new_val;end if;begin insert into sentry_projectcounter(project_id, value) values (project, delta) returning value into new_val;return new_val;exception when unique_violation then end;end loop;end $$ language plpgsql;","link":"/blog/2019/09/12/%E4%BD%BF%E7%94%A8Dock%E6%90%AD%E5%BB%BASentry%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"Docker","slug":"Docker","link":"/blog/tags/Docker/"},{"name":"TypeScript","slug":"TypeScript","link":"/blog/tags/TypeScript/"},{"name":"前端","slug":"前端","link":"/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Mongodb","slug":"Mongodb","link":"/blog/tags/Mongodb/"},{"name":"服务监控","slug":"服务监控","link":"/blog/tags/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/"},{"name":"docker","slug":"docker","link":"/blog/tags/docker/"}],"categories":[]}